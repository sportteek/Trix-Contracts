<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Runner Mini — Telegram WebApp</title>
<style>
  :root{
    --bg:#6fd3ff; --ground:#2d8f3b; --ui:#021926; --accent:#ffcc00;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#9ee6ff,#6fd3ff);-webkit-tap-highlight-color:transparent}
  #wrap{max-width:900px;margin:0 auto;padding:10px;height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:center}
  header{width:100%;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  header h1{font-size:18px;margin:0;color:#042632}
  #gameCanvas{border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.18);background:linear-gradient(#87e6ff,#4ccfff);width:100%;max-width:920px;height:auto}
  #controls{display:flex;gap:10px;margin-top:10px}
  .btn{padding:10px 14px;border-radius:10px;background:var(--ui);color:#fff;font-weight:700;border:0;min-width:84px;text-align:center}
  .small{color:#042632;font-size:13px}
  /* mobile-friendly layout */
  @media (max-width:640px){
    header h1{font-size:16px}
    .btn{min-width:70px;padding:10px}
  }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Runner Mini — Play in Telegram</h1>
    <div class="small">Score: <span id="score">0</span></div>
  </header>

  <canvas id="canvas" width="900" height="500"></canvas>

  <div id="controls">
    <button id="jump" class="btn">Jump</button>
    <button id="duck" class="btn">Duck</button>
    <button id="pause" class="btn">Pause</button>
  </div>

  <div style="height:10px"></div>
  <div class="small">Use buttons or ← → / Space / Down arrows. Works inline in Telegram.</div>
</div>

<script>
/* Endless runner (mobile-friendly) with Telegram WebApp support.
 - Simple procedural level: obstacles spawn from right
 - Player auto-runs; player can jump (tap) or duck (hold)
 - Score increments with distance; speed increases gradually
 - Integrates Telegram Web App SDK where available
*/

/* Telegram WebApp init (if opened inside Telegram) */
let tg = window.Telegram?.WebApp ?? null;
if(tg){
  try{ tg.expand(); }catch(e){}
  // show main button example (optional)
  if(tg.MainButton){
    tg.MainButton.text = "Close";
    tg.MainButton.show();
    tg.MainButton.onClick(()=> tg.close());
  }
}

/* Canvas setup */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let baseW = 900, baseH = 500;

function fitCanvas(){
  const parentW = Math.min(baseW, document.getElementById('wrap').clientWidth);
  const scale = parentW / baseW;
  canvas.style.width = (baseW * scale) + 'px';
  canvas.style.height = (baseH * scale) + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

/* Game state */
let scoreEl = document.getElementById('score');
let score = 0;
let alive = true;
let paused = false;

/* Player */
const player = {
  x: 120, y: 380, w: 46, h: 70,
  vy:0, onGround:true, jumpPower: -13,
  ducking:false,
  color: '#ff6b6b'
};

/* World */
let speed = 4.2; // base speed
let gravity = 0.7;
let obstacles = []; // {x,w,h,type}
let spawnTimer = 0;
let spawnInterval = 90; // frames
let frame = 0;

/* Input */
const input = { jump:false, duck:false };
document.getElementById('jump').addEventListener('touchstart', e=>{ e.preventDefault(); doJump(); }, {passive:false});
document.getElementById('jump').addEventListener('mousedown', e=> doJump());
document.getElementById('duck').addEventListener('touchstart', e=>{ e.preventDefault(); input.duck=true; }, {passive:false});
document.getElementById('duck').addEventListener('mousedown', e=> input.duck=true);
document.getElementById('duck').addEventListener('touchend', e=>{ e.preventDefault(); input.duck=false; }, {passive:false});
document.getElementById('duck').addEventListener('mouseup', e=> input.duck=false);
document.getElementById('pause').addEventListener('click', ()=> { paused = !paused; document.getElementById('pause').innerText = paused? 'Resume':'Pause'; });

window.addEventListener('keydown', e=>{
  if(e.code==='Space' || e.key==='ArrowUp') doJump();
  if(e.key==='ArrowDown') input.duck = true;
});
window.addEventListener('keyup', e=>{ if(e.key==='ArrowDown') input.duck = false; });

function doJump(){
  if(!alive || paused) return;
  if(player.onGround){
    player.vy = player.jumpPower;
    player.onGround = false;
  } else {
    // optionally allow double jump (disabled)
  }
}

/* helper */
function rand(min,max){ return Math.random()*(max-min)+min; }

/* obstacle generation */
function spawnObstacle(){
  const r = Math.random();
  if(r < 0.6){
    // small barrier (must jump)
    obstacles.push({x: baseW + 40, w: 34, h: 42, type:'low'});
  } else if(r < 0.9){
    // tall barrier (duck)
    obstacles.push({x: baseW + 40, w: 48, h: 90, type:'tall'});
  } else {
    // flying enemy (mid-air)
    obstacles.push({x: baseW + 40, w: 40, h: 36, type:'fly', yOffset: -70});
  }
}

/* collision check */
function rectsIntersect(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

function resetGame(){
  obstacles = [];
  score = 0; scoreEl.innerText = score;
  speed = 4.2; spawnInterval = 90;
  frame = 0; alive = true; paused = false;
  player.y = 380; player.vy = 0; player.onGround = true;
}

/* main loop */
function update(){
  if(paused) { requestAnimationFrame(update); return; }
  frame++;

  // physics
  player.vy += gravity;
  player.y += player.vy;
  if(player.y >= 380){ player.y = 380; player.vy = 0; player.onGround = true; }

  // duck handling
  player.ducking = input.duck;
  const ph = player.ducking ? player.h*0.52 : player.h;
  const py = player.ducking ? player.y + (player.h - ph) : player.y;

  // spawn obstacles
  spawnTimer++;
  if(spawnTimer > spawnInterval){
    spawnObstacle();
    spawnTimer = 0;
    // make spawn interval slightly random and shrink over time
    spawnInterval = Math.max(36, 90 - Math.floor(score/15) - Math.floor(Math.random()*10));
  }

  // move obstacles
  for(let i=obstacles.length-1;i>=0;i--){
    let ob = obstacles[i];
    ob.x -= speed + (score/200); // speed scales slightly with score
    // set y for flying obstacles
    ob.y = (ob.type==='fly') ? (380 - ob.h + (ob.yOffset||0)) : (380 + player.h - ob.h);
    // offscreen remove
    if(ob.x + ob.w < -40) obstacles.splice(i,1);
  }

  // collisions
  for(let ob of obstacles){
    const playerBox = {x:player.x, y:py, w:player.w, h:ph};
    const obBox = {x:ob.x, y:ob.y, w:ob.w, h:ob.h};
    if(rectsIntersect(playerBox, obBox)){
      // determine if it's a safe collision (e.g., jumping over low)
      if(ob.type==='low' && player.y + player.h - ob.h < 6 && player.vy < 0) {
        // jumped through—rare edge case
      } else {
        // hit — game over
        alive = false;
      }
    }
  }

  // scoring by distance
  if(alive){
    score += 1;
    scoreEl.innerText = score;
    // gradually increase base speed
    if(frame % 300 === 0) speed += 0.4;
  }

  draw();
  if(alive) requestAnimationFrame(update);
  else endRun();
}

function endRun(){
  // show result and provide restart
  setTimeout(()=> {
    const again = confirm('Game over — score: ' + score + '. Play again?');
    if(again) { resetGame(); requestAnimationFrame(update); }
    else {
      // if opened inside Telegram, provide a close button via SDK
      if(tg && tg.MainButton){ tg.MainButton.text='Close'; tg.MainButton.show(); tg.MainButton.onClick(()=> tg.close()); }
    }
  }, 150);
}

/* drawing */
function draw(){
  // clear logical canvas
  ctx.clearRect(0,0,baseW,baseH);

  // ground
  ctx.fillStyle = '#7ad170';
  ctx.fillRect(0,430,baseW,70);

  // distant parallax hills
  ctx.fillStyle = '#a1eac4';
  ctx.beginPath();
  ctx.ellipse(180,420,220,70,0,0,Math.PI*2);
  ctx.ellipse(520,430,260,80,0,0,Math.PI*2);
  ctx.fill();

  // obstacles
  for(let ob of obstacles){
    ctx.fillStyle = (ob.type==='fly')? '#b33' : '#3b2d20';
    ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    // small highlight
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(ob.x+6, ob.y+6, Math.max(6, ob.w-12), 6);
  }

  // player
  ctx.fillStyle = player.color;
  const drawH = player.ducking ? player.h*0.52 : player.h;
  const drawY = player.ducking ? player.y + (player.h - drawH) : player.y;
  // body
  roundRect(ctx, player.x, drawY, player.w, drawH, 8, true, false);
  // eye
  ctx.fillStyle = '#fff';
  ctx.fillRect(player.x + player.w - 16, drawY + 12, 6, 6);

  // HUD small
  ctx.fillStyle = '#083';
  ctx.font = '18px system-ui';
  ctx.fillText('Score: ' + score, 12, 28);
}

/* rounded rect helper */
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* start */
resetGame();
requestAnimationFrame(update);
</script>
</body>
</html>
